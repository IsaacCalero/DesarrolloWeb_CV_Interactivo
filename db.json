{
  "experiencia": [
    {
      "id": 1,
      "empresa": "FONAG",
      "puesto": "Digitador de Datos",
      "periodo": "2024 - 2024",
      "descripcion": "Digitalización de datos de pruebas para recolección de datos."
    },
    {
      "id": 2,
      "empresa": "PUCE (LTIC)",
      "puesto": "Ayudante",
      "periodo": "2025 - Actualidad",
      "descripcion": "Proporcionar soporte técnico a la facultad de ingeniería."
    }
  ],
  "estudios": [
    {
      "id": 1,
      "institucion": "Unidad Educativa Municipal Fernández Madrid",
      "titulo": "Bachiller en Ciencias",
      "periodo": "2018 - 2024",
      "descripcion": ""
    },
    {
      "id": 2,
      "institucion": "Pontificia Universidad Católica del Ecuador",
      "titulo": "Tecnología en Desarrollo de Software",
      "periodo": "2024 - Actualidad",
      "descripcion": ""
    }
  ],
  "posts": [
    {
      "id": 1,
      "titulo": "Cómo construir una lista de tareas con React y JSON Server",
      "fecha": "14-12-2025",
      "autor": "Isaac Calero",
      "resumen": "Tutorial técnico sobre cómo implementar las operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en una aplicación React usando Axios y JSON Server como backend simulado.",
      "contenido": "\n1. **Explicación de CRUD:**\nCRUD es un acrónimo que representa las cuatro operaciones básicas que se realizan sobre los datos en una aplicación:\n- **Crear (Create):** Permite agregar nuevos registros, como una nueva tarea.\n- **Leer (Read):** Permite obtener y mostrar la información almacenada.\n- **Actualizar (Update):** Permite modificar los datos existentes.\n- **Eliminar (Delete):** Permite borrar registros de la base de datos.\nEn este proyecto, estas operaciones se implementan usando React en el frontend y JSON Server como una API REST simulada.\n\n2. **Configuración:**\nPara simular una API se utiliza JSON Server, el cual expone endpoints REST a partir de un archivo JSON. Además, se usa Axios para realizar las peticiones HTTP desde React.\n\nInstalación de dependencias:\n- JSON Server: `npm install -g json-server`\n- Axios y React Router: `npm install axios react-router-dom`\n\nSe crea un archivo `db.json` que contiene la colección de tareas y se levanta el servidor con el comando `json-server --watch db.json --port 3001`.\n\n3. **Fragmento de Código GET/READ:**\nPara obtener la lista de tareas se utiliza Axios dentro de un custom hook, lo que permite reutilizar la lógica y mantener el código más limpio.\n\n```js\nimport { useEffect, useState } from 'react';\nimport axios from 'axios';\n\nconst useFetchTodos = () => {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() => {\n    axios.get('http://localhost:3001/todos')\n      .then(res => setTodos(res.data));\n  }, []);\n\n  return { todos };\n};\n```\n\nEste hook se encarga de leer los datos (READ) desde la API y devolverlos al componente.\n\n4. **Fragmento de Código POST/CREATE:**\nPara crear una nueva tarea se define una función que envía los datos al servidor usando el método POST.\n\n```js\nconst createTodo = async (todo) => {\n  await axios.post('http://localhost:3001/todos', todo);\n};\n```\n\nEsta función se ejecuta al enviar un formulario y permite agregar nuevas tareas a la lista.\n\n5. **Fragmento de Código PUT/UPDATE y DELETE:**\nLa actualización y eliminación de tareas se realizan utilizando los métodos PUT y DELETE. Para la edición se emplea React Router, permitiendo navegar a una vista específica según el ID de la tarea.\n\n```js\nconst updateTodo = async (id, updatedTodo) => {\n  await axios.put(`http://localhost:3001/todos/${id}`, updatedTodo);\n};\n\nconst deleteTodo = async (id) => {\n  await axios.delete(`http://localhost:3001/todos/${id}`);\n};\n```\n\nReact Router se utiliza para obtener el parámetro `id` desde la URL y cargar la información correspondiente en el formulario de edición, completando así el flujo CRUD de la aplicación."

    },
    {
      "id": 2,
      "titulo": "Análisis de la propuesta Await ",
      "fecha": "14-12-2025",
      "autor": "Isaac Calero",
      "resumen": "Un análisis profundo de la propuesta Temporal de TC39, que busca resolver los problemas de mutabilidad y manejo de zonas horarias en el objeto `Date` actual de JavaScript.",
      "contenido": "\n1. **¿Qué problema resuelve esta propuesta?**\nCuando se usan varias funciones asincrónicas con `await`, es común que se ejecuten una después de otra sin querer, lo que hace que el programa sea más lento. Aunque `Promise.all` permite ejecutar varias promesas al mismo tiempo, su uso con arreglos puede ser confuso, ya que depende del orden de los elementos y puede provocar errores si se mezclan los valores.\n\n2. **¿Cómo funciona `Promise.allKeyed`?**\n`Promise.allKeyed` propone una forma más clara de manejar varias promesas al mismo tiempo usando un objeto. En lugar de un arreglo, se pasa un objeto donde cada propiedad es una promesa. El resultado es otro objeto con las mismas claves, pero con los valores ya resueltos.\n\nEjemplo:\n\n```js\nconst { shape, color, mass } = await Promise.allKeyed({\n  shape: getShape(),\n  color: getColor(),\n  mass: getMass(),\n});\n```\n\nEsto hace que el código sea más fácil de leer y entender, ya que cada resultado mantiene su nombre.\n\n3. **¿Por qué es relevante para el futuro de JavaScript?**\nEsta propuesta busca que el manejo de código asincrónico sea más simple y menos propenso a errores. A medida que las aplicaciones web crecen y consumen más datos de forma paralela, contar con una sintaxis más clara ayuda a escribir código más mantenible.\n\n4. **Opinión personal**\nPersonalmente, entiendo esta propuesta como una forma de mejorar cómo trabajamos con varias tareas asincrónicas al mismo tiempo. En lugar de depender del orden como en Promise.all, Promise.allKeyed permite usar objetos, lo que hace que el código sea más claro y menos confuso. Me parece una idea útil porque ayuda a evitar errores y hace que el código sea más fácil de leer, especialmente en proyectos grandes donde se manejan muchas promesas a la vez."

    }
  ]
}